diff --git a/backends/dbfactory_remote.cc b/backends/dbfactory_remote.cc
index a46af11..3b39fdf 100644
--- a/backends/dbfactory_remote.cc
+++ b/backends/dbfactory_remote.cc
@@ -33,37 +33,37 @@ namespace Xapian {
 
 Database
 Remote::open(const string &host, unsigned int port, useconds_t timeout_,
-	     useconds_t connect_timeout)
+	     useconds_t connect_timeout, const string &dir)
 {
-    LOGCALL_STATIC(API, Database, "Remote::open", host | port | timeout_ | connect_timeout);
+    LOGCALL_STATIC(API, Database, "Remote::open", host | port | timeout_ | connect_timeout | dir);
     RETURN(Database(new RemoteTcpClient(host, port, timeout_ * 1e-3,
-					connect_timeout * 1e-3, false)));
+					connect_timeout * 1e-3, dir, false)));
 }
 
 WritableDatabase
 Remote::open_writable(const string &host, unsigned int port,
-		      useconds_t timeout_, useconds_t connect_timeout)
+		      useconds_t timeout_, useconds_t connect_timeout, const string &dir)
 {
-    LOGCALL_STATIC(API, WritableDatabase, "Remote::open_writable", host | port | timeout_ | connect_timeout);
+    LOGCALL_STATIC(API, WritableDatabase, "Remote::open_writable", host | port | timeout_ | connect_timeout | dir);
     RETURN(WritableDatabase(new RemoteTcpClient(host, port, timeout_ * 1e-3,
-						connect_timeout * 1e-3, true)));
+						connect_timeout * 1e-3, dir, true)));
 }
 
 Database
 Remote::open(const string &program, const string &args,
-	     useconds_t timeout_)
+	     useconds_t timeout_, const string &dir)
 {
-    LOGCALL_STATIC(API, Database, "Remote::open", program | args | timeout_);
-    RETURN(Database(new ProgClient(program, args, timeout_ * 1e-3, false)));
+    LOGCALL_STATIC(API, Database, "Remote::open", program | args | timeout_ | dir);
+    RETURN(Database(new ProgClient(program, args, timeout_ * 1e-3, dir, false)));
 }
 
 WritableDatabase
 Remote::open_writable(const string &program, const string &args,
-		      useconds_t timeout_)
+		      useconds_t timeout_, const string &dir)
 {
-    LOGCALL_STATIC(API, WritableDatabase, "Remote::open_writable", program | args | timeout_);
+    LOGCALL_STATIC(API, WritableDatabase, "Remote::open_writable", program | args | timeout_ | dir);
     RETURN(WritableDatabase(new ProgClient(program, args,
-					   timeout_ * 1e-3, true)));
+					   timeout_ * 1e-3, dir, true)));
 }
 
 }
diff --git a/backends/remote/remote-database.cc b/backends/remote/remote-database.cc
index 337865a..f1f2fbb 100644
--- a/backends/remote/remote-database.cc
+++ b/backends/remote/remote-database.cc
@@ -59,8 +59,9 @@ throw_bad_message(const string & context)
 }
 
 RemoteDatabase::RemoteDatabase(int fd, double timeout_,
-			       const string & context_, bool writable)
-	: link(fd, fd, context_),
+			       const string & context_, const string & dir, bool writable)
+	: db_dir(dir),
+	  link(fd, fd, context_),
 	  context(context_),
 	  cached_stats_valid(),
 	  mru_valstats(),
@@ -323,7 +324,7 @@ RemoteDatabase::update_stats(message_type msg_code) const
 
     string message;
     reply_type type = get_message(message);
-    if (type != REPLY_UPDATE || message.size() < 3) {
+    if (type != REPLY_UPDATE || message.size() < 2) {
 	if (type == REPLY_DONE) {
 	    // The database was already open at the latest revision.
 	    return false;
@@ -348,6 +349,22 @@ RemoteDatabase::update_stats(message_type msg_code) const
 	throw Xapian::NetworkError(errmsg, context);
     }
 
+    if (p == p_end) {
+        message.assign(encode_length(db_dir.size()));
+        message += db_dir;
+	send_message(MSG_SELECT, message);
+	get_message(message, REPLY_UPDATE);
+        if (message.size() < 3) {
+            throw Xapian::NetworkError("Database was not selected", context);
+        }
+
+	p = message.c_str();
+	p_end = p + message.size();
+
+	// The protocol versions where already checked.
+	p += 2;
+    }
+
     doccount = decode_length(&p, p_end, false);
     lastdocid = decode_length(&p, p_end, false) + doccount;
     doclen_lbound = decode_length(&p, p_end, false);
diff --git a/backends/remote/remote-database.h b/backends/remote/remote-database.h
index 0f33468..0e3d3ad 100644
--- a/backends/remote/remote-database.h
+++ b/backends/remote/remote-database.h
@@ -48,6 +48,10 @@ class RemoteDatabase : public Xapian::Database::Internal {
     /// Don't allow copying.
     RemoteDatabase(const RemoteDatabase &);
 
+    /** Directory to store databases in.
+     */
+    std::string db_dir;
+
     /// The object which does the I/O.
     mutable RemoteConnection link;
 
@@ -102,7 +106,7 @@ class RemoteDatabase : public Xapian::Database::Internal {
      *  @param context_ The context to return with any error messages.
      *	@param writable	Is this a WritableDatabase?
      */
-    RemoteDatabase(int fd, double timeout_, const string & context_,
+    RemoteDatabase(int fd, double timeout_, const string & context_, const string & dir,
 		   bool writable);
 
     /// Receive a message from the server.
diff --git a/common/remoteprotocol.h b/common/remoteprotocol.h
index beef08f..a015a0f 100644
--- a/common/remoteprotocol.h
+++ b/common/remoteprotocol.h
@@ -88,6 +88,7 @@ enum message_type {
     MSG_METADATAKEYLIST,	// Iterator for metadata keys
     MSG_FREQS,			// Get termfreq and collfreq
     MSG_UNIQUETERMS,		// Get number of unique terms in doc
+    MSG_SELECT,			// Select current database
     MSG_MAX
 };
 
diff --git a/include/xapian/dbfactory.h b/include/xapian/dbfactory.h
index 7ded352..ebd328b 100644
--- a/include/xapian/dbfactory.h
+++ b/include/xapian/dbfactory.h
@@ -173,7 +173,7 @@ namespace Remote {
  *				10000ms, which is 10 seconds).
  */
 XAPIAN_VISIBILITY_DEFAULT
-Database open(const std::string &host, unsigned int port, useconds_t timeout = 10000, useconds_t connect_timeout = 10000);
+Database open(const std::string &host, unsigned int port, useconds_t timeout = 10000, useconds_t connect_timeout = 10000, const std::string &dir = std::string());
 
 /** Construct a WritableDatabase object for update access to a remote database
  *  accessed via a TCP connection.
@@ -194,7 +194,7 @@ Database open(const std::string &host, unsigned int port, useconds_t timeout = 1
  *				10000ms, which is 10 seconds).
  */
 XAPIAN_VISIBILITY_DEFAULT
-WritableDatabase open_writable(const std::string &host, unsigned int port, useconds_t timeout = 0, useconds_t connect_timeout = 10000);
+WritableDatabase open_writable(const std::string &host, unsigned int port, useconds_t timeout = 0, useconds_t connect_timeout = 10000, const std::string &dir = std::string());
 
 /** Construct a Database object for read-only access to a remote database
  *  accessed via a program.
@@ -211,7 +211,7 @@ WritableDatabase open_writable(const std::string &host, unsigned int port, useco
  *			is 10 seconds).
  */
 XAPIAN_VISIBILITY_DEFAULT
-Database open(const std::string &program, const std::string &args, useconds_t timeout = 10000);
+Database open(const std::string &program, const std::string &args, useconds_t timeout = 10000, const std::string &dir = std::string());
 
 /** Construct a WritableDatabase object for update access to a remote database
  *  accessed via a program.
@@ -227,7 +227,7 @@ Database open(const std::string &program, const std::string &args, useconds_t ti
  *			is 0, which means don't timeout).
  */
 XAPIAN_VISIBILITY_DEFAULT
-WritableDatabase open_writable(const std::string &program, const std::string &args, useconds_t timeout = 0);
+WritableDatabase open_writable(const std::string &program, const std::string &args, useconds_t timeout = 0, const std::string &dir = std::string());
 
 }
 #endif
diff --git a/net/progclient.cc b/net/progclient.cc
index 34805af..976374e 100644
--- a/net/progclient.cc
+++ b/net/progclient.cc
@@ -64,13 +64,13 @@ split_words(const string &text, vector<string> &words, char ws = ' ')
 #endif
 
 ProgClient::ProgClient(const string &progname, const string &args,
-		       double timeout_, bool writable)
+		       double timeout_, const string & dir, bool writable)
 	: RemoteDatabase(run_program(progname, args
 #ifndef __WIN32__
 						   , pid
 #endif
         ),
-			 timeout_, get_progcontext(progname, args), writable)
+			 timeout_, get_progcontext(progname, args), dir, writable)
 {
     LOGCALL_CTOR(DB, "ProgClient", progname | args | timeout_ | writable);
 }
diff --git a/net/progclient.h b/net/progclient.h
index e64bc51..6e49657 100644
--- a/net/progclient.h
+++ b/net/progclient.h
@@ -85,7 +85,7 @@ class ProgClient : public RemoteDatabase {
      */
     ProgClient(const std::string &progname,
 	       const std::string &arg,
-	       double msecs_timeout,
+	       double msecs_timeout, const std::string & dir,
 	       bool writable);
 
     /** Destructor. */
diff --git a/net/remoteserver.cc b/net/remoteserver.cc
index a96619d..14c70f0 100644
--- a/net/remoteserver.cc
+++ b/net/remoteserver.cc
@@ -53,101 +53,73 @@ throw_read_only()
     throw Xapian::InvalidOperationError("Server is read-only");
 }
 
+XAPIAN_NORETURN(static void throw_no_db());
+static void
+throw_no_db()
+{
+    throw Xapian::InvalidOperationError("Server has no open database");
+}
+
 /// Class to throw when we receive the connection closing message.
 struct ConnectionClosed { };
 
-RemoteServer::RemoteServer(const std::vector<std::string> &dbpaths,
-			   int fdin_, int fdout_,
-			   double active_timeout_, double idle_timeout_,
-			   bool writable_)
-    : RemoteConnection(fdin_, fdout_, std::string()),
-      db(NULL), wdb(NULL), writable(writable_),
-      active_timeout(active_timeout_), idle_timeout(idle_timeout_)
-{
-    // Catch errors opening the database and propagate them to the client.
-    try {
-	Assert(!dbpaths.empty());
-	// We always open the database read-only to start with.  If we're
-	// writable, the client can ask to be upgraded to write access once
-	// connected if it wants it.
-	db = new Xapian::Database(dbpaths[0]);
-	// Build a better description than Database::get_description() gives
-	// in the variable context.  FIXME: improve Database::get_description()
-	// and then just use that instead.
-	context = dbpaths[0];
 
-	if (!writable) {
-	    vector<std::string>::const_iterator i(dbpaths.begin());
-	    for (++i; i != dbpaths.end(); ++i) {
-		db->add_database(Xapian::Database(*i));
-		context += ' ';
-		context += *i;
-	    }
-	} else {
-	    AssertEq(dbpaths.size(), 1); // Expecting exactly one database.
+/** Structure holding a match and a list of match spies.
+ *
+ *  The main reason for the existence of this structure is to allow passing
+ *  match state between query and mset. ensure that the match spies are all
+ *  deleted after use.
+ */
+struct MatchState {
+    Xapian::Database *db;
+    MultiMatch *match;
+    vector<Xapian::MatchSpy *> spies;
+    Xapian::Weight *wt;
+    MatchState() : match(NULL), wt(NULL) {}
+    ~MatchState() {
+	vector<Xapian::MatchSpy *>::const_iterator i;
+	for (i = spies.begin(); i != spies.end(); ++i) {
+	    delete *i;
+	}
+	if (match) {
+		delete match;
+	}
+	if (wt) {
+		delete wt;
 	}
-    } catch (const Xapian::Error &err) {
-	// Propagate the exception to the client.
-	send_message(REPLY_EXCEPTION, serialise_error(err));
-	// And rethrow it so our caller can log it and close the connection.
-	throw;
     }
+};
 
-#ifndef __WIN32__
-    // It's simplest to just ignore SIGPIPE.  We'll still know if the
-    // connection dies because we'll get EPIPE back from write().
-    if (signal(SIGPIPE, SIG_IGN) == SIG_ERR)
-	throw Xapian::NetworkError("Couldn't set SIGPIPE to SIG_IGN", errno);
-#endif
 
-    // Send greeting message.
-    msg_update(string());
-}
+typedef void (RemoteProtocol::* dispatch_func)(const string &);
 
-RemoteServer::~RemoteServer()
-{
-    delete db;
-    // wdb is either NULL or equal to db, so we shouldn't delete it too!
-}
+RemoteProtocol::RemoteProtocol(const std::vector<std::string> &dbpaths_,
+			       double active_timeout_,
+			       double idle_timeout_,
+			       bool writable_)
+    : matchstate(NULL), required_type(MSG_MAX),
+      dbpaths(dbpaths_), writable(writable_),
+      active_timeout(active_timeout_), idle_timeout(idle_timeout_)
+{}
 
-message_type
-RemoteServer::get_message(double timeout, string & result,
-			  message_type required_type)
+RemoteProtocol::~RemoteProtocol()
 {
-    double end_time = RealTime::end_time(timeout);
-    unsigned int type = RemoteConnection::get_message(result, end_time);
-
-    // Handle "shutdown connection" message here.
-    if (type == MSG_SHUTDOWN) throw ConnectionClosed();
-    if (type >= MSG_MAX) {
-	string errmsg("Invalid message type ");
-	errmsg += str(type);
-	throw Xapian::NetworkError(errmsg);
-    }
-    if (required_type != MSG_MAX && type != unsigned(required_type)) {
-	string errmsg("Expecting message type ");
-	errmsg += str(int(required_type));
-	errmsg += ", got ";
-	errmsg += str(int(type));
-	throw Xapian::NetworkError(errmsg);
-    }
-    return static_cast<message_type>(type);
+	cleanup();
 }
 
 void
-RemoteServer::send_message(reply_type type, const string &message)
+RemoteProtocol::cleanup()
 {
-    double end_time = RealTime::end_time(active_timeout);
-    unsigned char type_as_char = static_cast<unsigned char>(type);
-    RemoteConnection::send_message(type_as_char, message, end_time);
+    if (matchstate != NULL) {
+	MatchState *matchstate_ = static_cast<MatchState *>(matchstate);
+	release_db(matchstate_->db);
+	delete matchstate_;
+    }
 }
 
-typedef void (RemoteServer::* dispatch_func)(const string &);
-
 void
-RemoteServer::run()
+RemoteProtocol::run_one()
 {
-    while (true) {
 	try {
 	    /* This list needs to be kept in the same order as the list of
 	     * message types in "remoteprotocol.h". Note that messages at the
@@ -155,40 +127,42 @@ RemoteServer::run()
 	     * don't correspond to dispatch actions.
 	     */
 	    static const dispatch_func dispatch[] = {
-		&RemoteServer::msg_allterms,
-		&RemoteServer::msg_collfreq,
-		&RemoteServer::msg_document,
-		&RemoteServer::msg_termexists,
-		&RemoteServer::msg_termfreq,
-		&RemoteServer::msg_valuestats,
-		&RemoteServer::msg_keepalive,
-		&RemoteServer::msg_doclength,
-		&RemoteServer::msg_query,
-		&RemoteServer::msg_termlist,
-		&RemoteServer::msg_positionlist,
-		&RemoteServer::msg_postlist,
-		&RemoteServer::msg_reopen,
-		&RemoteServer::msg_update,
-		&RemoteServer::msg_adddocument,
-		&RemoteServer::msg_cancel,
-		&RemoteServer::msg_deletedocumentterm,
-		&RemoteServer::msg_commit,
-		&RemoteServer::msg_replacedocument,
-		&RemoteServer::msg_replacedocumentterm,
-		&RemoteServer::msg_deletedocument,
-		&RemoteServer::msg_writeaccess,
-		&RemoteServer::msg_getmetadata,
-		&RemoteServer::msg_setmetadata,
-		&RemoteServer::msg_addspelling,
-		&RemoteServer::msg_removespelling,
-		0, // MSG_GETMSET - used during a conversation.
-		0, // MSG_SHUTDOWN - handled by get_message().
-		&RemoteServer::msg_openmetadatakeylist,
-		&RemoteServer::msg_uniqueterms,
+		&RemoteProtocol::msg_allterms,
+		&RemoteProtocol::msg_collfreq,
+		&RemoteProtocol::msg_document,
+		&RemoteProtocol::msg_termexists,
+		&RemoteProtocol::msg_termfreq,
+		&RemoteProtocol::msg_valuestats,
+		&RemoteProtocol::msg_keepalive,
+		&RemoteProtocol::msg_doclength,
+		&RemoteProtocol::msg_query,
+		&RemoteProtocol::msg_termlist,
+		&RemoteProtocol::msg_positionlist,
+		&RemoteProtocol::msg_postlist,
+		&RemoteProtocol::msg_reopen,
+		&RemoteProtocol::msg_update,
+		&RemoteProtocol::msg_adddocument,
+		&RemoteProtocol::msg_cancel,
+		&RemoteProtocol::msg_deletedocumentterm,
+		&RemoteProtocol::msg_commit,
+		&RemoteProtocol::msg_replacedocument,
+		&RemoteProtocol::msg_replacedocumentterm,
+		&RemoteProtocol::msg_deletedocument,
+		&RemoteProtocol::msg_writeaccess,
+		&RemoteProtocol::msg_getmetadata,
+		&RemoteProtocol::msg_setmetadata,
+		&RemoteProtocol::msg_addspelling,
+		&RemoteProtocol::msg_removespelling,
+		&RemoteProtocol::msg_getmset,
+		&RemoteProtocol::msg_shutdown,
+		&RemoteProtocol::msg_openmetadatakeylist,
+		&RemoteProtocol::msg_freqs,
+		&RemoteProtocol::msg_uniqueterms,
+		&RemoteProtocol::msg_select,
 	    };
 
 	    string message;
-	    size_t type = get_message(idle_timeout, message);
+	    size_t type = get_message(idle_timeout, message, required_type);
 	    if (type >= sizeof(dispatch)/sizeof(dispatch[0]) || !dispatch[type]) {
 		string errmsg("Unexpected message type ");
 		errmsg += str(type);
@@ -226,18 +200,22 @@ RemoteServer::run()
 	    // connection.
 	    throw;
 	}
-    }
 }
 
+
 void
-RemoteServer::msg_allterms(const string &message)
+RemoteProtocol::msg_allterms(const string &message)
 {
+    Xapian::Database * db_ = get_db(false);
+    if (!db_)
+	throw_no_db();
+
     string prev = message;
     string reply;
 
     const string & prefix = message;
-    const Xapian::TermIterator end = db->allterms_end(prefix);
-    for (Xapian::TermIterator t = db->allterms_begin(prefix); t != end; ++t) {
+    const Xapian::TermIterator end = db_->allterms_end(prefix);
+    for (Xapian::TermIterator t = db_->allterms_begin(prefix); t != end; ++t) {
 	if (rare(prev.size() > 255))
 	    prev.resize(255);
 	const string & v = *t;
@@ -250,19 +228,25 @@ RemoteServer::msg_allterms(const string &message)
     }
 
     send_message(REPLY_DONE, string());
+
+    release_db(db_);
 }
 
 void
-RemoteServer::msg_termlist(const string &message)
+RemoteProtocol::msg_termlist(const string &message)
 {
+    Xapian::Database * db_ = get_db(false);
+    if (!db_)
+	throw_no_db();
+
     const char *p = message.data();
     const char *p_end = p + message.size();
     Xapian::docid did = decode_length(&p, p_end, false);
 
-    send_message(REPLY_DOCLENGTH, encode_length(db->get_doclength(did)));
+    send_message(REPLY_DOCLENGTH, encode_length(db_->get_doclength(did)));
     string prev;
-    const Xapian::TermIterator end = db->termlist_end(did);
-    for (Xapian::TermIterator t = db->termlist_begin(did); t != end; ++t) {
+    const Xapian::TermIterator end = db_->termlist_end(did);
+    for (Xapian::TermIterator t = db_->termlist_begin(did); t != end; ++t) {
 	if (rare(prev.size() > 255))
 	    prev.resize(255);
 	const string & v = *t;
@@ -276,19 +260,25 @@ RemoteServer::msg_termlist(const string &message)
     }
 
     send_message(REPLY_DONE, string());
+
+    release_db(db_);
 }
 
 void
-RemoteServer::msg_positionlist(const string &message)
+RemoteProtocol::msg_positionlist(const string &message)
 {
+    Xapian::Database * db_ = get_db(false);
+    if (!db_)
+	throw_no_db();
+
     const char *p = message.data();
     const char *p_end = p + message.size();
     Xapian::docid did = decode_length(&p, p_end, false);
     string term(p, p_end - p);
 
     Xapian::termpos lastpos = static_cast<Xapian::termpos>(-1);
-    const Xapian::PositionIterator end = db->positionlist_end(did, term);
-    for (Xapian::PositionIterator i = db->positionlist_begin(did, term);
+    const Xapian::PositionIterator end = db_->positionlist_end(did, term);
+    for (Xapian::PositionIterator i = db_->positionlist_begin(did, term);
 	 i != end; ++i) {
 	Xapian::termpos pos = *i;
 	send_message(REPLY_POSITIONLIST, encode_length(pos - lastpos - 1));
@@ -296,20 +286,60 @@ RemoteServer::msg_positionlist(const string &message)
     }
 
     send_message(REPLY_DONE, string());
+
+    release_db(db_);
 }
 
+
+void
+RemoteProtocol::msg_writeaccess(const string & msg)
+{
+    if (!writable)
+	throw_read_only();
+
+    select_db(dbpaths, true);
+
+    msg_update(msg);
+}
+
+
 void
-RemoteServer::msg_postlist(const string &message)
+RemoteProtocol::msg_select(const string &message)
 {
+    const char *p = message.c_str();
+    const char *p_end = p + message.size();
+
+    std::vector<string> dbpaths_;
+
+    while (p != p_end) {
+	size_t len = decode_length(&p, p_end, true);
+	string dbpath(p, len);
+	dbpaths_.push_back(dbpath);
+	p += len;
+    }
+
+    select_db(dbpaths_, false);
+
+    msg_update(message);
+}
+
+
+void
+RemoteProtocol::msg_postlist(const string &message)
+{
+    Xapian::Database * db_ = get_db(false);
+    if (!db_)
+	throw_no_db();
+
     const string & term = message;
 
-    Xapian::doccount termfreq = db->get_termfreq(term);
-    Xapian::termcount collfreq = db->get_collection_freq(term);
+    Xapian::doccount termfreq = db_->get_termfreq(term);
+    Xapian::termcount collfreq = db_->get_collection_freq(term);
     send_message(REPLY_POSTLISTSTART, encode_length(termfreq) + encode_length(collfreq));
 
     Xapian::docid lastdocid = 0;
-    const Xapian::PostingIterator end = db->postlist_end(term);
-    for (Xapian::PostingIterator i = db->postlist_begin(term);
+    const Xapian::PostingIterator end = db_->postlist_end(term);
+    for (Xapian::PostingIterator i = db_->postlist_begin(term);
 	 i != end; ++i) {
 
 	Xapian::docid newdocid = *i;
@@ -321,72 +351,62 @@ RemoteServer::msg_postlist(const string &message)
     }
 
     send_message(REPLY_DONE, string());
-}
-
-void
-RemoteServer::msg_writeaccess(const string & msg)
-{
-    if (!writable) 
-	throw_read_only();
 
-    wdb = new Xapian::WritableDatabase(context, Xapian::DB_OPEN);
-    delete db;
-    db = wdb;
-    msg_update(msg);
+    release_db(db_);
 }
 
 void
-RemoteServer::msg_reopen(const string & msg)
+RemoteProtocol::msg_reopen(const string & msg)
 {
-    if (!db->reopen()) {
+    Xapian::Database * db_ = get_db(false);
+    if (!db_)
+	throw_no_db();
+
+    if (!db_->reopen()) {
 	send_message(REPLY_DONE, string());
+	release_db(db_);
 	return;
     }
+
     msg_update(msg);
+    release_db(db_);
 }
 
 void
-RemoteServer::msg_update(const string &)
+RemoteProtocol::msg_update(const string &)
 {
+    Xapian::Database * db_ = get_db(false);
+
     static const char protocol[2] = {
 	char(XAPIAN_REMOTE_PROTOCOL_MAJOR_VERSION),
 	char(XAPIAN_REMOTE_PROTOCOL_MINOR_VERSION)
     };
-    string message(protocol, 2);
-    Xapian::doccount num_docs = db->get_doccount();
-    message += encode_length(num_docs);
-    message += encode_length(db->get_lastdocid() - num_docs);
-    Xapian::termcount doclen_lb = db->get_doclength_lower_bound();
-    message += encode_length(doclen_lb);
-    message += encode_length(db->get_doclength_upper_bound() - doclen_lb);
-    message += (db->has_positions() ? '1' : '0');
-    // FIXME: clumsy to reverse calculate total_len like this:
-    totlen_t total_len = totlen_t(db->get_avlength() * db->get_doccount() + .5);
-    message += encode_length(total_len);
-    //message += encode_length(db->get_total_length());
-    string uuid = db->get_uuid();
-    message += uuid;
-    send_message(REPLY_UPDATE, message);
-}
 
-/** Structure holding a list of match spies.
- *
- *  The main reason for the existence of this structure is to make it easy to
- *  ensure that the match spies are all deleted after use.
- */
-struct MatchSpyList {
-    vector<Xapian::MatchSpy *> spies;
+    string message(protocol, 2);
 
-    ~MatchSpyList() {
-	vector<Xapian::MatchSpy *>::const_iterator i;
-	for (i = spies.begin(); i != spies.end(); ++i) {
-	    delete *i;
-	}
+    if (db_) {
+	Xapian::doccount num_docs = db_->get_doccount();
+	message += encode_length(num_docs);
+	message += encode_length(db_->get_lastdocid() - num_docs);
+	Xapian::termcount doclen_lb = db_->get_doclength_lower_bound();
+	message += encode_length(doclen_lb);
+	message += encode_length(db_->get_doclength_upper_bound() - doclen_lb);
+	message += (db_->has_positions() ? '1' : '0');
+	// FIXME: clumsy to reverse calculate total_len like this:
+	totlen_t total_len = totlen_t(db_->get_avlength() * db_->get_doccount() + .5);
+	message += encode_length(total_len);
+	//message += encode_length(db_->get_total_length());
+	string uuid = db_->get_uuid();
+	message += uuid;
     }
-};
+
+    send_message(REPLY_UPDATE, message);
+
+    release_db(db_);
+}
 
 void
-RemoteServer::msg_query(const string &message_in)
+RemoteProtocol::msg_query(const string &message_in)
 {
     const char *p = message_in.c_str();
     const char *p_end = p + message_in.size();
@@ -450,8 +470,17 @@ RemoteServer::msg_query(const string &message_in)
 					   wtname + " not registered");
     }
 
+    MatchState * matchstate_;
+    if (matchstate != NULL) {
+    	matchstate_ = static_cast<MatchState *>(matchstate);
+    	delete matchstate_;
+    }
+
+    matchstate_ = new MatchState();
+    matchstate = matchstate_;
+
     len = decode_length(&p, p_end, true);
-    AutoPtr<Xapian::Weight> wt(wttype->unserialise(string(p, len)));
+    matchstate_->wt = wttype->unserialise(string(p, len));
     p += len;
 
     // Unserialise the RSet object.
@@ -460,7 +489,6 @@ RemoteServer::msg_query(const string &message_in)
     p += len;
 
     // Unserialise any MatchSpy objects.
-    MatchSpyList matchspies;
     while (p != p_end) {
 	len = decode_length(&p, p_end, true);
 	string spytype(p, len);
@@ -472,22 +500,38 @@ RemoteServer::msg_query(const string &message_in)
 	p += len;
 
 	len = decode_length(&p, p_end, true);
-	matchspies.spies.push_back(spyclass->unserialise(string(p, len), reg));
+	matchstate_->spies.push_back(spyclass->unserialise(string(p, len), reg));
 	p += len;
     }
 
     Xapian::Weight::Internal local_stats;
-    MultiMatch match(*db, query, qlen, &rset, collapse_max, collapse_key,
+
+    Xapian::Database * db_ = get_db(false);
+    if (!db_)
+	throw_no_db();
+
+    matchstate_->match = new MultiMatch(*db_, query, qlen, &rset, collapse_max, collapse_key,
 		     percent_cutoff, weight_cutoff, order,
 		     sort_key, sort_by, sort_value_forward, time_limit, NULL,
-		     local_stats, wt.get(), matchspies.spies, false, false);
+		     local_stats, matchstate_->wt, matchstate_->spies, false, false);
+    matchstate_->db = db_;
 
     send_message(REPLY_STATS, serialise_stats(local_stats));
 
-    string message;
-    get_message(active_timeout, message, MSG_GETMSET);
-    p = message.c_str();
-    p_end = p + message.size();
+    required_type = MSG_GETMSET;
+}
+
+void
+RemoteProtocol::msg_getmset(const string & msg)
+{
+    if (matchstate == NULL) {
+	throw Xapian::NetworkError("Unexpected MSG_GETMSET");
+    }
+
+    MatchState *matchstate_ = static_cast<MatchState *>(matchstate);
+
+    const char *p = msg.c_str();
+    const char *p_end = p + msg.size();
 
     Xapian::termcount first = decode_length(&p, p_end, false);
     Xapian::termcount maxitems = decode_length(&p, p_end, false);
@@ -495,34 +539,45 @@ RemoteServer::msg_query(const string &message_in)
     Xapian::termcount check_at_least = 0;
     check_at_least = decode_length(&p, p_end, false);
 
-    message.erase(0, message.size() - (p_end - p));
+    std::string message(p, p_end);
     AutoPtr<Xapian::Weight::Internal> total_stats(new Xapian::Weight::Internal);
     unserialise_stats(message, *(total_stats.get()));
-    total_stats->set_bounds_from_db(*db);
+    total_stats->set_bounds_from_db(*matchstate_->db);
 
     Xapian::MSet mset;
-    match.get_mset(first, maxitems, check_at_least, mset, *(total_stats.get()), 0, 0);
+    matchstate_->match->get_mset(first, maxitems, check_at_least, mset, *(total_stats.get()), 0, 0);
     mset.internal->stats = total_stats.release();
 
     message.resize(0);
     vector<Xapian::MatchSpy *>::const_iterator i;
-    for (i = matchspies.spies.begin(); i != matchspies.spies.end(); ++i) {
+    for (i = matchstate_->spies.begin(); i != matchstate_->spies.end(); ++i) {
 	string spy_results = (*i)->serialise_results();
 	message += encode_length(spy_results.size());
 	message += spy_results;
     }
     message += serialise_mset(mset);
     send_message(REPLY_RESULTS, message);
+
+    matchstate = NULL;
+
+    required_type = MSG_MAX;
+
+    release_db(matchstate_->db);
+    delete matchstate_;
 }
 
 void
-RemoteServer::msg_document(const string &message)
+RemoteProtocol::msg_document(const string &message)
 {
+    Xapian::Database * db_ = get_db(false);
+    if (!db_)
+	throw_no_db();
+
     const char *p = message.data();
     const char *p_end = p + message.size();
     Xapian::docid did = decode_length(&p, p_end, false);
 
-    Xapian::Document doc = db->get_document(did);
+    Xapian::Document doc = db_->get_document(did);
 
     send_message(REPLY_DOCDATA, doc.get_data());
 
@@ -533,155 +588,224 @@ RemoteServer::msg_document(const string &message)
 	send_message(REPLY_VALUE, item);
     }
     send_message(REPLY_DONE, string());
+
+    release_db(db_);
 }
 
 void
-RemoteServer::msg_keepalive(const string &)
+RemoteProtocol::msg_keepalive(const string &)
 {
+    Xapian::Database * db_ = get_db(false);
+    if (!db_)
+	throw_no_db();
+
     // Ensure *our* database stays alive, as it may contain remote databases!
-    db->keep_alive();
+    db_->keep_alive();
     send_message(REPLY_DONE, string());
+
+    release_db(db_);
 }
 
 void
-RemoteServer::msg_termexists(const string &term)
+RemoteProtocol::msg_termexists(const string &term)
 {
-    send_message((db->term_exists(term) ? REPLY_TERMEXISTS : REPLY_TERMDOESNTEXIST), string());
+    Xapian::Database * db_ = get_db(false);
+    if (!db_)
+	throw_no_db();
+
+    send_message((db_->term_exists(term) ? REPLY_TERMEXISTS : REPLY_TERMDOESNTEXIST), string());
+
+    release_db(db_);
 }
 
 void
-RemoteServer::msg_collfreq(const string &term)
+RemoteProtocol::msg_collfreq(const string &term)
 {
-    send_message(REPLY_COLLFREQ, encode_length(db->get_collection_freq(term)));
+    Xapian::Database * db_ = get_db(false);
+    if (!db_)
+	throw_no_db();
+
+    send_message(REPLY_COLLFREQ, encode_length(db_->get_collection_freq(term)));
+
+    release_db(db_);
 }
 
 void
-RemoteServer::msg_termfreq(const string &term)
+RemoteProtocol::msg_termfreq(const string &term)
 {
-    send_message(REPLY_TERMFREQ, encode_length(db->get_termfreq(term)));
+    Xapian::Database * db_ = get_db(false);
+    if (!db_)
+	throw_no_db();
+
+    send_message(REPLY_TERMFREQ, encode_length(db_->get_termfreq(term)));
+
+    release_db(db_);
 }
 
 void
-RemoteServer::msg_freqs(const string &term)
+RemoteProtocol::msg_freqs(const string &term)
 {
-    string msg = encode_length(db->get_termfreq(term));
-    msg += encode_length(db->get_collection_freq(term));
+    Xapian::Database * db_ = get_db(false);
+    if (!db_)
+	throw_no_db();
+
+    string msg = encode_length(db_->get_termfreq(term));
+    msg += encode_length(db_->get_collection_freq(term));
     send_message(REPLY_FREQS, msg);
+
+    release_db(db_);
 }
 
 void
-RemoteServer::msg_valuestats(const string & message)
+RemoteProtocol::msg_valuestats(const string & message)
 {
+    Xapian::Database * db_ = get_db(false);
+    if (!db_)
+	throw_no_db();
+
     const char *p = message.data();
     const char *p_end = p + message.size();
     while (p != p_end) {
 	Xapian::valueno slot = decode_length(&p, p_end, false);
 	string message_out;
-	message_out += encode_length(db->get_value_freq(slot));
-	string bound = db->get_value_lower_bound(slot);
+	message_out += encode_length(db_->get_value_freq(slot));
+	string bound = db_->get_value_lower_bound(slot);
 	message_out += encode_length(bound.size());
 	message_out += bound;
-	bound = db->get_value_upper_bound(slot);
+	bound = db_->get_value_upper_bound(slot);
 	message_out += encode_length(bound.size());
 	message_out += bound;
 
 	send_message(REPLY_VALUESTATS, message_out);
     }
+
+    release_db(db_);
 }
 
 void
-RemoteServer::msg_doclength(const string &message)
+RemoteProtocol::msg_doclength(const string &message)
 {
+    Xapian::Database * db_ = get_db(false);
+    if (!db_)
+	throw_no_db();
+
     const char *p = message.data();
     const char *p_end = p + message.size();
     Xapian::docid did = decode_length(&p, p_end, false);
-    send_message(REPLY_DOCLENGTH, encode_length(db->get_doclength(did)));
+    send_message(REPLY_DOCLENGTH, encode_length(db_->get_doclength(did)));
+
+    release_db(db_);
 }
 
 void
-RemoteServer::msg_uniqueterms(const string &message)
+RemoteProtocol::msg_uniqueterms(const string &message)
 {
+    Xapian::Database * db_ = get_db(false);
+    if (!db_)
+	throw_no_db();
+
     const char *p = message.data();
     const char *p_end = p + message.size();
     Xapian::docid did = decode_length(&p, p_end, false);
-    send_message(REPLY_UNIQUETERMS, encode_length(db->get_unique_terms(did)));
+    send_message(REPLY_UNIQUETERMS, encode_length(db_->get_unique_terms(did)));
+
+    release_db(db_);
 }
 
 void
-RemoteServer::msg_commit(const string &)
+RemoteProtocol::msg_commit(const string &)
 {
-    if (!wdb)
+    Xapian::WritableDatabase * wdb_ = static_cast<Xapian::WritableDatabase *>(get_db(true));
+    if (!wdb_)
 	throw_read_only();
 
-    wdb->commit();
+    wdb_->commit();
 
     send_message(REPLY_DONE, string());
+
+    release_db(wdb_);
 }
 
 void
-RemoteServer::msg_cancel(const string &)
+RemoteProtocol::msg_cancel(const string &)
 {
-    if (!wdb)
+    Xapian::WritableDatabase * wdb_ = static_cast<Xapian::WritableDatabase *>(get_db(true));
+    if (!wdb_)
 	throw_read_only();
 
     // We can't call cancel since that's an internal method, but this
     // has the same effect with minimal additional overhead.
-    wdb->begin_transaction(false);
-    wdb->cancel_transaction();
+    wdb_->begin_transaction(false);
+    wdb_->cancel_transaction();
+
+    release_db(wdb_);
 }
 
 void
-RemoteServer::msg_adddocument(const string & message)
+RemoteProtocol::msg_adddocument(const string & message)
 {
-    if (!wdb)
+    Xapian::WritableDatabase * wdb_ = static_cast<Xapian::WritableDatabase *>(get_db(true));
+    if (!wdb_)
 	throw_read_only();
 
-    Xapian::docid did = wdb->add_document(unserialise_document(message));
+    Xapian::docid did = wdb_->add_document(unserialise_document(message));
 
     send_message(REPLY_ADDDOCUMENT, encode_length(did));
+
+    release_db(wdb_);
 }
 
 void
-RemoteServer::msg_deletedocument(const string & message)
+RemoteProtocol::msg_deletedocument(const string & message)
 {
-    if (!wdb)
+    Xapian::WritableDatabase * wdb_ = static_cast<Xapian::WritableDatabase *>(get_db(true));
+    if (!wdb_)
 	throw_read_only();
 
     const char *p = message.data();
     const char *p_end = p + message.size();
     Xapian::docid did = decode_length(&p, p_end, false);
 
-    wdb->delete_document(did);
+    wdb_->delete_document(did);
 
     send_message(REPLY_DONE, string());
+
+    release_db(wdb_);
 }
 
 void
-RemoteServer::msg_deletedocumentterm(const string & message)
+RemoteProtocol::msg_deletedocumentterm(const string & message)
 {
-    if (!wdb)
+    Xapian::WritableDatabase * wdb_ = static_cast<Xapian::WritableDatabase *>(get_db(true));
+    if (!wdb_)
 	throw_read_only();
 
-    wdb->delete_document(message);
+    wdb_->delete_document(message);
+
+    release_db(wdb_);
 }
 
 void
-RemoteServer::msg_replacedocument(const string & message)
+RemoteProtocol::msg_replacedocument(const string & message)
 {
-    if (!wdb)
+    Xapian::WritableDatabase * wdb_ = static_cast<Xapian::WritableDatabase *>(get_db(true));
+    if (!wdb_)
 	throw_read_only();
 
     const char *p = message.data();
     const char *p_end = p + message.size();
     Xapian::docid did = decode_length(&p, p_end, false);
 
-    wdb->replace_document(did, unserialise_document(string(p, p_end)));
+    wdb_->replace_document(did, unserialise_document(string(p, p_end)));
+
+    release_db(wdb_);
 }
 
 void
-RemoteServer::msg_replacedocumentterm(const string & message)
+RemoteProtocol::msg_replacedocumentterm(const string & message)
 {
-    if (!wdb)
+    Xapian::WritableDatabase * wdb_ = static_cast<Xapian::WritableDatabase *>(get_db(true));
+    if (!wdb_)
 	throw_read_only();
 
     const char *p = message.data();
@@ -690,26 +814,38 @@ RemoteServer::msg_replacedocumentterm(const string & message)
     string unique_term(p, len);
     p += len;
 
-    Xapian::docid did = wdb->replace_document(unique_term, unserialise_document(string(p, p_end)));
+    Xapian::docid did = wdb_->replace_document(unique_term, unserialise_document(string(p, p_end)));
 
     send_message(REPLY_ADDDOCUMENT, encode_length(did));
+
+    release_db(wdb_);
 }
 
 void
-RemoteServer::msg_getmetadata(const string & message)
+RemoteProtocol::msg_getmetadata(const string & message)
 {
-    send_message(REPLY_METADATA, db->get_metadata(message));
+    Xapian::Database * db_ = get_db(false);
+    if (!db_)
+	throw_no_db();
+
+    send_message(REPLY_METADATA, db_->get_metadata(message));
+
+    release_db(db_);
 }
 
 void
-RemoteServer::msg_openmetadatakeylist(const string & message)
+RemoteProtocol::msg_openmetadatakeylist(const string & message)
 {
+    Xapian::Database * db_ = get_db(false);
+    if (!db_)
+	throw_no_db();
+
     string prev = message;
     string reply;
 
     const string & prefix = message;
-    const Xapian::TermIterator end = db->metadata_keys_end(prefix);
-    Xapian::TermIterator t = db->metadata_keys_begin(prefix);
+    const Xapian::TermIterator end = db_->metadata_keys_end(prefix);
+    Xapian::TermIterator t = db_->metadata_keys_begin(prefix);
     for (; t != end; ++t) {
 	if (rare(prev.size() > 255))
 	    prev.resize(255);
@@ -721,12 +857,15 @@ RemoteServer::msg_openmetadatakeylist(const string & message)
 	prev = v;
     }
     send_message(REPLY_DONE, string());
+
+    release_db(db_);
 }
 
 void
-RemoteServer::msg_setmetadata(const string & message)
+RemoteProtocol::msg_setmetadata(const string & message)
 {
-    if (!wdb)
+    Xapian::WritableDatabase * wdb_ = static_cast<Xapian::WritableDatabase *>(get_db(true));
+    if (!wdb_)
 	throw_read_only();
     const char *p = message.data();
     const char *p_end = p + message.size();
@@ -734,27 +873,162 @@ RemoteServer::msg_setmetadata(const string & message)
     string key(p, keylen);
     p += keylen;
     string val(p, p_end - p);
-    wdb->set_metadata(key, val);
+    wdb_->set_metadata(key, val);
+    release_db(wdb_);
 }
 
 void
-RemoteServer::msg_addspelling(const string & message)
+RemoteProtocol::msg_addspelling(const string & message)
 {
-    if (!wdb)
+    Xapian::WritableDatabase * wdb_ = static_cast<Xapian::WritableDatabase *>(get_db(true));
+    if (!wdb_)
 	throw_read_only();
     const char *p = message.data();
     const char *p_end = p + message.size();
     Xapian::termcount freqinc = decode_length(&p, p_end, false);
-    wdb->add_spelling(string(p, p_end - p), freqinc);
+    wdb_->add_spelling(string(p, p_end - p), freqinc);
+    release_db(wdb_);
 }
 
 void
-RemoteServer::msg_removespelling(const string & message)
+RemoteProtocol::msg_removespelling(const string & message)
 {
-    if (!wdb)
+    Xapian::WritableDatabase * wdb_ = static_cast<Xapian::WritableDatabase *>(get_db(true));
+    if (!wdb_)
 	throw_read_only();
     const char *p = message.data();
     const char *p_end = p + message.size();
     Xapian::termcount freqdec = decode_length(&p, p_end, false);
-    wdb->remove_spelling(string(p, p_end - p), freqdec);
+    wdb_->remove_spelling(string(p, p_end - p), freqdec);
+    release_db(wdb_);
+}
+
+void
+RemoteProtocol::msg_shutdown(const string &)
+{
+	shutdown();
+}
+
+
+Xapian::Database *
+RemoteServer::get_db(bool writable_) {
+    if (writable_) {
+	return wdb;
+    } else {
+	return db;
+    }
+}
+
+void
+RemoteServer::select_db(const std::vector<std::string> &dbpaths_, bool writable_) {
+    delete db;
+    if (writable_) {
+    	wdb = new Xapian::WritableDatabase(dbpaths_[0], Xapian::DB_OPEN);
+    	db = wdb;
+    } else {
+	wdb = NULL;
+	db = new Xapian::Database(dbpaths_[0], Xapian::DB_OPEN);
+	// Build a better description than Database::get_description() gives
+	// in the variable context.  FIXME: improve Database::get_description()
+	// and then just use that instead.
+	context = dbpaths_[0];
+	if (!writable) {
+	    vector<std::string>::const_iterator i(dbpaths_.begin());
+	    for (++i; i != dbpaths_.end(); ++i) {
+		db->add_database(Xapian::Database(*i));
+		context += ' ';
+		context += *i;
+	    }
+	} else {
+	    AssertEq(dbpaths_.size(), 1); // Expecting exactly one database.
+	}
+    }
+    dbpaths = dbpaths_;
+}
+
+
+RemoteServer::RemoteServer(const std::vector<std::string> &dbpaths_,
+			   int fdin_, int fdout_,
+			   double active_timeout_, double idle_timeout_,
+			   bool writable_)
+    : RemoteConnection(fdin_, fdout_, std::string()),
+      RemoteProtocol(dbpaths_, active_timeout_, idle_timeout_, writable_),
+      db(NULL), wdb(NULL)
+{
+    // Catch errors opening the database and propagate them to the client.
+    try {
+	Assert(!dbpaths_.empty());
+	// We always open the database read-only to start with.  If we're
+	// writable, the client can ask to be upgraded to write access once
+	// connected if it wants it.
+	select_db(dbpaths_, false);
+    } catch (const Xapian::Error &err) {
+	// Propagate the exception to the client.
+	send_message(REPLY_EXCEPTION, serialise_error(err));
+	// And rethrow it so our caller can log it and close the connection.
+	throw;
+    }
+
+#ifndef __WIN32__
+    // It's simplest to just ignore SIGPIPE.  We'll still know if the
+    // connection dies because we'll get EPIPE back from write().
+    if (signal(SIGPIPE, SIG_IGN) == SIG_ERR)
+	throw Xapian::NetworkError("Couldn't set SIGPIPE to SIG_IGN", errno);
+#endif
+
+    // Send greeting message.
+    msg_update(string());
+}
+
+RemoteServer::~RemoteServer()
+{
+    if (db != NULL) delete db;
+    // wdb is either NULL or equal to db, so we shouldn't delete it too!
+}
+
+message_type
+RemoteServer::get_message(double timeout, string & result,
+			  message_type required_type)
+{
+    double end_time = RealTime::end_time(timeout);
+    unsigned int type = RemoteConnection::get_message(result, end_time);
+
+    // Handle "shutdown connection" message here.
+    if (type == MSG_SHUTDOWN) throw ConnectionClosed();
+    if (type >= MSG_MAX) {
+	string errmsg("Invalid message type ");
+	errmsg += str(type);
+	throw Xapian::NetworkError(errmsg);
+    }
+    if (required_type != MSG_MAX && type != unsigned(required_type)) {
+	string errmsg("Expecting message type ");
+	errmsg += str(int(required_type));
+	errmsg += ", got ";
+	errmsg += str(int(type));
+	throw Xapian::NetworkError(errmsg);
+    }
+    return static_cast<message_type>(type);
+}
+
+void
+RemoteServer::send_message(reply_type type, const string &message)
+{
+    double end_time = RealTime::end_time(active_timeout);
+    unsigned char type_as_char = static_cast<unsigned char>(type);
+    RemoteConnection::send_message(type_as_char, message, end_time);
+}
+
+void
+RemoteServer::send_message(reply_type type, const std::string &message, double end_time) {
+    unsigned char type_as_char = static_cast<unsigned char>(type);
+    RemoteConnection::send_message(type_as_char, message, end_time);
+}
+
+
+void
+RemoteServer::run()
+{
+    while (true) {
+    	run_one();
+    }
 }
diff --git a/net/remoteserver.h b/net/remoteserver.h
index 857d791..94ec8c9 100644
--- a/net/remoteserver.h
+++ b/net/remoteserver.h
@@ -32,56 +32,36 @@
 
 #include <string>
 
-/** Remote backend server base class. */
-class XAPIAN_VISIBILITY_DEFAULT RemoteServer : private RemoteConnection {
-    /// Don't allow assignment.
-    void operator=(const RemoteServer &);
-
-    /// Don't allow copying.
-    RemoteServer(const RemoteServer &);
-
-    /** The database we're using.
-     *
-     *  If we're writable, this is the same as wdb.
-     */
-    Xapian::Database * db;
 
-    /// The WritableDatabase we're using, or NULL if we're read-only.
-    Xapian::WritableDatabase * wdb;
-
-    /// Do we support writing?
-    bool writable;
-
-    /** Timeout for actions during a conversation.
-     *
-     *  The timeout is specified in seconds.  If the timeout is exceeded then a
-     *  Xapian::NetworkTimeoutError is thrown.
-     */
-    double active_timeout;
+/** Structure holding a list of match spies.
+ *
+ *  The main reason for the existence of this structure is to make it easy to
+ *  ensure that the match spies are all deleted after use.
+ */
 
-    /** Timeout while waiting for a new action from the client.
-     *
-     *  The timeout is specified in seconds.  If the timeout is exceeded then a
-     *  Xapian::NetworkTimeoutError is thrown.
-     */
-    double idle_timeout;
 
-    /// The registry, which allows unserialisation of user subclasses.
-    Xapian::Registry reg;
+class XAPIAN_VISIBILITY_DEFAULT RemoteProtocol {
+    void *matchstate;
+    message_type required_type;
 
+  protected:
     /// Accept a message from the client.
-    message_type get_message(double timeout, std::string & result,
-			     message_type required_type = MSG_MAX);
+    virtual message_type get_message(double timeout, std::string & result,
+                                     message_type required_type = MSG_MAX) = 0;
 
     /// Send a message to the client.
-    void send_message(reply_type type, const std::string &message);
+    virtual void send_message(reply_type type, const std::string &message) = 0;
 
     /// Send a message to the client, with specific end_time.
-    void send_message(reply_type type, const std::string &message,
-		      double end_time) {
-	unsigned char type_as_char = static_cast<unsigned char>(type);
-	RemoteConnection::send_message(type_as_char, message, end_time);
-    }
+    virtual void send_message(reply_type type, const std::string &message,
+                              double end_time) = 0;
+
+    virtual Xapian::Database * get_db(bool) = 0;
+    virtual void release_db(Xapian::Database *) = 0;
+    virtual void select_db(const std::vector<std::string> &, bool) = 0;
+    virtual void shutdown() {};
+
+    void cleanup();
 
     // all terms
     void msg_allterms(const std::string & message);
@@ -170,6 +150,79 @@ class XAPIAN_VISIBILITY_DEFAULT RemoteServer : private RemoteConnection {
     // get number of unique terms
     void msg_uniqueterms(const std::string & message);
 
+    // select the active database
+    void msg_select(const std::string & message);
+
+    void msg_getmset(const std::string & message);
+
+    void msg_shutdown(const std::string & message);
+
+    void run_one();
+
+  public:
+    /// The registry, which allows unserialisation of user subclasses.
+    Xapian::Registry reg;
+
+    std::vector<std::string> dbpaths;
+
+    /// Do we support writing?
+    bool writable;
+
+    /** Timeout for actions during a conversation.
+     *
+     *  The timeout is specified in seconds.  If the timeout is exceeded then a
+     *  Xapian::NetworkTimeoutError is thrown.
+     */
+    double active_timeout;
+
+    /** Timeout while waiting for a new action from the client.
+     *
+     *  The timeout is specified in seconds.  If the timeout is exceeded then a
+     *  Xapian::NetworkTimeoutError is thrown.
+     */
+    double idle_timeout;
+
+    RemoteProtocol(const std::vector<std::string> &dbpaths,
+                 double active_timeout_,
+                 double idle_timeout_,
+                 bool writable = false);
+
+    virtual ~RemoteProtocol();
+};
+
+
+/** Remote backend server base class. */
+class XAPIAN_VISIBILITY_DEFAULT RemoteServer : private RemoteConnection, public RemoteProtocol {
+    /// Don't allow assignment.
+    void operator=(const RemoteServer &);
+
+    /// Don't allow copying.
+    RemoteServer(const RemoteServer &);
+
+    /** The database we're using.
+     *
+     *  If we're writable, this is the same as wdb.
+     */
+    Xapian::Database * db;
+
+    /// The WritableDatabase we're using, or NULL if we're read-only.
+    Xapian::WritableDatabase * wdb;
+
+    /// Accept a message from the client.
+    message_type get_message(double timeout, std::string & result,
+			     message_type required_type = MSG_MAX);
+
+    /// Send a message to the client.
+    void send_message(reply_type type, const std::string &message);
+
+    /// Send a message to the client, with specific end_time.
+    void send_message(reply_type type, const std::string &message,
+                      double end_time);
+
+    Xapian::Database * get_db(bool writable_);
+    void release_db(Xapian::Database *) {};
+    void select_db(const std::vector<std::string> &dbpaths_, bool writable_);
+
   public:
     /** Construct a RemoteServer.
      *
@@ -192,18 +245,19 @@ class XAPIAN_VISIBILITY_DEFAULT RemoteServer : private RemoteConnection {
     /// Destructor.
     ~RemoteServer();
 
-    /** Repeatedly accept messages from the client and process them.
-     *
-     *  The loop continues until either the connection is closed, or a
-     *  non-Xapian exception is thrown.
-     */
-    void run();
 
     /// Get the registry used for (un)serialisation.
     const Xapian::Registry & get_registry() const { return reg; }
 
     /// Set the registry used for (un)serialisation.
     void set_registry(const Xapian::Registry & reg_) { reg = reg_; }
+
+    /** Repeatedly accept messages from the client and process them.
+     *
+     *  The loop continues until either the connection is closed, or a
+     *  non-Xapian exception is thrown.
+     */
+     void run();
 };
 
 #endif // XAPIAN_INCLUDED_REMOTESERVER_H
diff --git a/net/remotetcpclient.h b/net/remotetcpclient.h
index 7a6fa5f..f065ca6 100644
--- a/net/remotetcpclient.h
+++ b/net/remotetcpclient.h
@@ -73,10 +73,10 @@ class RemoteTcpClient : SOCKET_INITIALIZER_MIXIN public RemoteDatabase {
      *	@param writable		Is this a WritableDatabase?
      */
     RemoteTcpClient(const std::string & hostname, int port,
-		    double timeout_, double timeout_connect, bool writable)
+		    double timeout_, double timeout_connect, const std::string & dir, bool writable)
 	: RemoteDatabase(open_socket(hostname, port, timeout_connect),
 			 timeout_, get_tcpcontext(hostname, port),
-			 writable) { }
+			 dir, writable) { }
 
     /** Destructor. */
     ~RemoteTcpClient();
