#!/usr/bin/python
from __future__ import print_function

# This is a simple port-forward / proxy, written using only the default python
# library. If you want to make a suggestion or fix something you can contact-me
# at voorloop_at_gmail.com
# Distributed over IDC(I Don't Care) license
import socket
import select
import time
import sys
import os

# Changing the buffer_size and delay, you can improve the speed and bandwidth.
# But when buffer get to high or delay go too down, you can broke things
buffer_size = 4096
delay = 0.0001

INCOMING = 0
OUTGOING = 1


def decode_length(buf, check=False):
    size = 0
    length = buf[0]
    buf = buf[1:]
    size += 1
    if length == b'\xff':
        length = 0
        shift = 0
        sz = 0
        for ch in buf:
            ch = ord(ch)
            length |= (ch & 0x7f) << shift
            shift += 7
            sz += 1
            if ch & 0x80:
                break
        else:
            raise ValueError("Bad encoded length: insufficient data")
        length += 255
        buf = buf[sz:]
        size += sz
    else:
        length = ord(length)
    if check and len(buf) < length:
        raise ValueError("Bad encoded length: insufficient data")
    return length, size, buf[length:]


def decode_string(buf):
    length, size, new_buf = decode_length(buf, True)
    msg_length, msg_body = buf[:size], buf[size:size + length]
    return length, msg_length, msg_body, new_buf


class Forward(object):
    def __init__(self):
        self.forward = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

    def start(self, host, port):
        try:
            self.forward.connect((host, port))
            return self.forward
        except Exception, e:
            print(e)
            return False


class ProxyServer(object):
    input_list = []
    channel = {}
    reads = {}

    def __init__(self, forward_from, forward_to):
        self.server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        self.server.bind(forward_from)
        self.server.listen(200)
        self.forward_to = forward_to
        self.forward_from = forward_from

    def main_loop(self):
        self.input_list.append(self.server)
        while 1:
            time.sleep(delay)
            ss = select.select
            inputready, outputready, exceptready = ss(self.input_list, [], [])
            for self.s in inputready:
                if self.s == self.server:
                    self._on_accept()
                    break
                self.data = self.s.recv(buffer_size)
                if len(self.data) == 0:
                    self._on_close()
                    break
                else:
                    self._on_recv()

    def get_args(self, s):
        out, direction = self.channel[s]
        forward_from, forward_to = (out, s) if direction else (s, out)
        from_client, from_peer = forward_from.getpeername()[1], forward_from.getsockname()[1]
        to_client, to_peer = forward_to.getsockname()[1], forward_to.getpeername()[1]
        return out, from_client, from_peer, to_client, to_peer, direction

    def _on_accept(self):
        forward = Forward().start(self.forward_to[0], self.forward_to[1])
        clientsock, clientaddr = self.server.accept()
        if forward:
            self.input_list.append(clientsock)
            self.input_list.append(forward)
            self.channel[clientsock] = (forward, INCOMING)
            self.channel[forward] = (clientsock, OUTGOING)
            out, from_client, from_peer, to_client, to_peer, direction = self.get_args(clientsock)
            self.on_accept(from_client, from_peer, to_client, to_peer, direction)
        else:
            print("Can't establish connection with remote server.", end="")
            print("Closing connection with client side", clientaddr)
            clientsock.close()

    def _on_close(self):
        out, from_client, from_peer, to_client, to_peer, direction = self.get_args(self.s)
        self.on_close(from_client, from_peer, to_client, to_peer, direction)
        # remove objects from input_list
        self.input_list.remove(self.s)
        self.input_list.remove(self.channel[self.s][0])
        out = self.channel[self.s][0]
        # close the connection with client
        self.channel[out][0].close()  # equivalent to do self.s.close()
        # close the connection with remote server
        self.channel[self.s][0].close()
        # delete both objects from channel dict
        del self.channel[out]
        del self.channel[self.s]

    def _on_recv(self):
        # here we can parse and/or modify the data before send forward
        out, from_client, from_peer, to_client, to_peer, direction = self.get_args(self.s)
        data = self.on_recv(self.data, from_client, from_peer, to_client, to_peer, direction)
        if data is None:
            data = self.data
        if data:
            out.send(data)

    def repr(self, from_client, from_peer, to_client, to_peer, direction):
        return "%10s - %s" % (from_client, (" <-- " if direction else " --> ").join(str(p) for p in (from_peer, to_peer)))

    def on_accept(self, from_client, from_peer, to_client, to_peer, direction):
        msg = "client has connected to %s" % from_peer
        print("%10s - %s" % (from_client, msg))

    def on_recv(self, data, from_client, from_peer, to_client, to_peer, direction):
        self.reads.setdefault(from_client, [0, 0])[direction] += len(data)
        print("%s: %r" % (self.repr(from_client, from_peer, to_client, to_peer, direction), data))

    def on_close(self, from_client, from_peer, to_client, to_peer, direction):
        in_read = self.reads.setdefault(from_client, [0, 0])[INCOMING]
        out_read = self.reads.setdefault(from_client, [0, 0])[OUTGOING]
        msg = "%s %s closed the connection (client sent %s bytes and received %s)" % ("server listening on" if direction else "client connected to", to_peer if direction else from_peer, in_read, out_read)
        print("%10s - %s" % (from_client, msg))
        del self.reads[from_client]


def enum_dict(*args):
    ret = {}
    for i, arg in enumerate(args):
        ret[i] = arg
        ret[arg] = i
    return ret


class XapianProxyServer(ProxyServer):
    """
    Xapian binary Protocol

    """
    buffers = {}

    messages = {
        'REMOTE': enum_dict(
            'MSG_ALLTERMS',             # All Terms
            'MSG_COLLFREQ',             # Get Collection Frequency
            'MSG_DOCUMENT',             # Get Document
            'MSG_TERMEXISTS',           # Term Exists?
            'MSG_TERMFREQ',             # Get Term Frequency
            'MSG_VALUESTATS',           # Get value statistics
            'MSG_KEEPALIVE',            # Keep-alive
            'MSG_DOCLENGTH',            # Get Doc Length
            'MSG_QUERY',                # Run Query
            'MSG_TERMLIST',             # Get TermList
            'MSG_POSITIONLIST',         # Get PositionList
            'MSG_POSTLIST',             # Get PostList
            'MSG_REOPEN',               # Reopen
            'MSG_UPDATE',               # Get Updated DocCount and AvLength
            'MSG_ADDDOCUMENT',          # Add Document
            'MSG_CANCEL',               # Cancel
            'MSG_DELETEDOCUMENTTERM',   # Delete Document by term
            'MSG_COMMIT',               # Commit
            'MSG_REPLACEDOCUMENT',      # Replace Document
            'MSG_REPLACEDOCUMENTTERM',  # Replace Document by term
            'MSG_DELETEDOCUMENT',       # Delete Document
            'MSG_WRITEACCESS',          # Upgrade to WritableDatabase
            'MSG_GETMETADATA',          # Get metadata
            'MSG_SETMETADATA',          # Set metadata
            'MSG_ADDSPELLING',          # Add a spelling
            'MSG_REMOVESPELLING',       # Remove a spelling
            'MSG_GETMSET',              # Get MSet
            'MSG_SHUTDOWN',             # Shutdown
            'MSG_METADATAKEYLIST',      # Iterator for metadata keys
            'MSG_FREQS',                # Get termfreq and collfreq
            'MSG_UNIQUETERMS',          # Get number of unique terms in doc
            'MSG_SELECT',               # Select current database
        ),
        'REPL': enum_dict(
            'REPLY_END_OF_CHANGES',
            'REPLY_FAIL',
            'REPLY_DB_HEADER',
            'REPLY_DB_FILENAME',
            'REPLY_DB_FILEDATA',
            'REPLY_DB_FOOTER',
            'REPLY_CHANGESET',
            'MSG_GET_CHANGESETS',
        ),
        'STORING': enum_dict(
            'REPLY_READY',
            'REPLY_DONE',
            'REPLY_FILE',
            'REPLY_DATA',
            'MSG_CREATE',
            'MSG_OPEN',
            'MSG_READ',
        ),
    }

    replies = {
        'REMOTE': enum_dict(
            'REPLY_UPDATE',             # Updated database stats
            'REPLY_EXCEPTION',          # Exception
            'REPLY_DONE',               # Done sending list
            'REPLY_ALLTERMS',           # All Terms
            'REPLY_COLLFREQ',           # Get Collection Frequency
            'REPLY_DOCDATA',            # Get Document
            'REPLY_TERMDOESNTEXIST',    # Term Doesn't Exist
            'REPLY_TERMEXISTS',         # Term Exists
            'REPLY_TERMFREQ',           # Get Term Frequency
            'REPLY_VALUESTATS',         # Value statistics
            'REPLY_DOCLENGTH',          # Get Doc Length
            'REPLY_STATS',              # Stats
            'REPLY_TERMLIST',           # Get Termlist
            'REPLY_POSITIONLIST',       # Get PositionList
            'REPLY_POSTLISTSTART',      # Start of a postlist
            'REPLY_POSTLISTITEM',       # Item in body of a postlist
            'REPLY_VALUE',              # Document Value
            'REPLY_ADDDOCUMENT',        # Add Document
            'REPLY_RESULTS',            # Results (MSet)
            'REPLY_METADATA',           # Metadata
            'REPLY_METADATAKEYLIST',    # Iterator for metadata keys
            'REPLY_FREQS',              # Get termfreq and collfreq
            'REPLY_UNIQUETERMS',        # Get number of unique terms in doc
        ),
        'REPL': enum_dict(
            '_REPLY_END_OF_CHANGES',
            '_REPLY_FAIL',
            '_REPLY_DB_HEADER',
            '_REPLY_DB_FILENAME',
            '_REPLY_DB_FILEDATA',
            '_REPLY_DB_FOOTER',
            '_REPLY_CHANGESET',
            '_MSG_GET_CHANGESETS',
        ),
        'STORING': enum_dict(
            '_REPLY_READY',
            '_REPLY_DONE',
            '_REPLY_FILE',
            '_REPLY_DATA',
            '_MSG_CREATE',
            '_MSG_OPEN',
            '_MSG_READ',
        ),
    }

    def on_accept(self, from_client, from_peer, to_client, to_peer, direction):
        super(XapianProxyServer, self).on_accept(from_client, from_peer, to_client, to_peer, direction)
        self.protocol = 'REMOTE'

    def on_recv(self, data, from_client, from_peer, to_client, to_peer, direction):
        super(XapianProxyServer, self).on_recv(data, from_client, from_peer, to_client, to_peer, direction)
        buf = self.buffers.setdefault(from_client, ['', ''])[direction] + data
        while buf:
            try:
                msg_id = buf[0]
                cmd = ord(msg_id)
                length, msg_length, msg_body, buf = decode_string(buf[1:])
                assert length == len(msg_body)
                if not direction and cmd == ord('\xfe'):
                    self.protocol = 'REPL'
                    cmd = self.messages[self.protocol]['MSG_GET_CHANGESETS']
                elif not direction and cmd == ord('\xfd'):
                    self.protocol = 'STORING'
                    cmd = self.messages[self.protocol]['MSG_CREATE']
                try:
                    msg = (self.replies[self.protocol] if direction else self.messages[self.protocol])[cmd]
                except KeyError:
                    msg = 'UNKNOWN'
                dir_repr = "<<<" if direction else ">>>"
                self.dump_print("%s: %s %s" % (self.protocol, msg, dir_repr), msg_id)
                dump_func = 'dump_%s_%s' % (self.protocol, msg)
                try:
                    getattr(self, dump_func.lower(), self.dump)(length, msg_length, msg_body)
                except Exception:
                    self.dump_print("ERROR", "Bad message!!")
                    self.dump(length, msg_length, msg_body)

            except ValueError:
                break
        self.buffers[from_client][direction] = buf

    def dump_print(self, name, value):
        print("%35s %r" % ("%s:" % name, value))

    def dump(self, length, msg_length, msg_body):
        self.dump_print("length(%s)" % length, msg_length)
        self.dump_print("body", msg_body)

    def dump_repl_msg_get_changesets(self, length, msg_length, msg_body):
        buf = msg_body
        length, msg_length, uuid, buf = decode_string(buf)
        length, msg_length, from_revision, buf = decode_string(buf)
        length, msg_length, index_path, buf = decode_string(buf)

        self.dump_print("uuid", uuid)
        self.dump_print("from_revision", from_revision)
        self.dump_print("index_path", index_path)
        if buf:
            self.dump_print("body", buf)

    def on_close(self, from_client, from_peer, to_client, to_peer, direction):
        super(XapianProxyServer, self).on_close(from_client, from_peer, to_client, to_peer, direction)
        buf = self.buffers.setdefault(from_client, ['', ''])[direction]
        if buf:
            print("%s bytes where left in the buffer" % len(buf))
        del self.buffers[from_client]


if __name__ == '__main__':
    default_server_class = ProxyServer
    opts = [a for a in sys.argv[1:] if a.startswith('-')]
    args = [a for a in sys.argv[1:] if not a.startswith('-')]
    if '--raw' in opts:
        server_class = ProxyServer
    elif '--xapian' in opts:
        server_class = XapianProxyServer
    else:
        server_class = default_server_class
    try:
        host, _, port = args[1].partition(':')
        if not port:
            host, port = 'localhost', host
        server = server_class(('', int(args[0])), (host, int(port)))
    except IndexError:
        print("Proxy listens to <in_port> and redirects traffic to a server listening on <out_port>")
        print("usage: %s [--xapian|--raw] <in_port> [<host>:]<out_port>" % os.path.basename(sys.argv[0]))
        print("example:")
        print("    %s --xapian 8860 localhost:8890" % os.path.basename(sys.argv[0]))
        sys.exit(1)
    try:
        server.main_loop()
    except KeyboardInterrupt:
        print("Ctrl C - Stopping server")
        sys.exit(1)
